<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by CDI for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        </description>
        <priority>1</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
])
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::VariableDeclarator/VariableDeclaratorId/@Name
])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Interface defines constants. It may expose implementation details." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
 //ClassOrInterfaceDeclaration[@Interface=true()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public interface Foo {
    static final Object CONST = new Object(); //bad
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false"
          dfa="false" language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe. The usual solution
            is to create a new local one when needed in a method.
        </description>
        <priority>1</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator/VariableInitializer/Expression[typeIs('java.text.DecimalFormat') or typeIs('java.text.ChoiceFormat')]
        ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidDeprecatedHttpConnectors" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Avoid the use of deprecated/thread-unsafe HTTP connectors" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi06" >
        <description>Problem: Several HTTP client connection managers are thread-unsafe which may cause session data mix-up or have other issues for which they were made deprecated.&#13;
            Solutions: Use org.apache.http.impl.conn.PoolingHttpClientConnectionManager and org.apache.http.impl.client.HttpClientBuilder. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration/Name[@Image='org.apache.commons.httpclient.SimpleHttpConnectionManager'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.http.impl.conn.PoolingClientConnectionManager'
or @Image='org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager'
or @Image='org.apache.http.impl.conn.SingleClientConnManager'
or @Image='org.apache.http.impl.client.DefaultHttpClient'
or @Image='org.apache.http.impl.client.SystemDefaultHttpClient'
or @Image='org.apache.http.conn.ClientConnectionManager'
]
|
//TypeDeclaration//ClassOrInterfaceDeclaration//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/
Type/ReferenceType/ClassOrInterfaceType[typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')
or typeIs('org.apache.http.conn.ClientConnectionManager')
or typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or typeIs('org.apache.http.impl.client.DefaultHttpClient')
or typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or typeIs('org.apache.http.conn.ClientConnectionManager')
]
|
//TypeDeclaration//ClassOrInterfaceDeclaration//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/
VariableDeclarator/VariableInitializer/Expression//AllocationExpression/ClassOrInterfaceType[
typeIs('org.apache.http.conn.ClientConnectionManager')
or typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or typeIs('org.apache.http.impl.client.DefaultHttpClient')
or typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or typeIs('org.apache.http.conn.ClientConnectionManager')
]
|
//AllocationExpression/ClassOrInterfaceType[typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')]
		     ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected are different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//SwitchStatement/BlockStatement[
(.//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
or
.//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image)
and
.//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
not(.//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimarySuffix/Arguments/@Size > 0
or preceding-sibling::SwitchLabel[@Default='true'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitely compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitely on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.replaceAll') or ends-with(@Image, '.replaceFirst') or ends-with(@Image, 'Pattern.matches')]/../../PrimarySuffix/Arguments[ArgumentList/@Size=2]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.split') or ends-with(@Image, 'getPathMatcher')]/../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
(:--- not (if foreign field (with .), or field with short String or without regex char) ---:)
Name[contains(@Image, '.') or @Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimarySuffix[@Image='getPathMatcher']/../PrimarySuffix/Arguments[ArgumentList/@Size=1]/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]]/VariableDeclaratorId/@Name])
]
,
(: --- String.matches called on formalparams, locals and fields --- :)
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.matches')]
[
(exists(index-of((ancestor::MethodDeclaration//FormalParameter[pmd-java:typeIs('java.lang.String')]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[pmd-java:typeIs('java.lang.String')]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('java.lang.String')]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.'))))
and
(: for matches param is >5 literal or something named :)
../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
(: exclude method calls :)
and not(../PrimarySuffix)
(: exclude for param is method arg or local :)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
(: exclude for param is short fields :)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]
]/VariableDeclaratorId/@Name])
]])
]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Default capacity constructor of ByteArrayOutputStream or StringWriter is used, it usually needs expensive expansions." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>Default constructor of ByteArrayOutputStream or StringWriter is used. Problem: It allocates a small buffer as capacity which usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
	//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[typeIs('java.io.ByteArrayOutputStream') or typeIs('java.io.StringWriter')]
[not(../Arguments/ArgumentList)]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidMultipleConcatStatements" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Multiple statements concatenate to the same String. Use StringBuilder append." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBuilder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name
[@Image=./../../../../../../../../../../../..//VariableDeclaratorId/@Name
and
./../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]
]
/../../../AssignmentOperator[@Image='+=']/
../Expression//PrimaryExpression/PrimaryPrefix/Name) > 1]/BlockStatement[position()=last()]
|
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression[
./PrimaryExpression/PrimaryPrefix/Name[
@Image = ../../../Expression/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
@Image = ./../../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]/../../../VariableDeclarator/VariableDeclaratorId/@Name
]
]) > 1 ]//BlockStatement[position()=last()]//StatementExpression/Expression/AdditiveExpression[@Operator = '+']
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidRecompilingPatterns" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.util.regex.Pattern') and ends-with(@Image, '.compile') and
count(../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression) = 1
and not (
../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
lass Bad {
    public static final String STR_PAT1 = "[A-Z][a-z]+";

    public static void bad() {
        Pattern p1 = Pattern.compile(STR_PAT1); // bad
        Pattern p2 = Pattern.compile("(?=\\p{Lu})"); // bad
        boolean b = p1.matcher("Start ").matches();
    }
}
class Good {
    public static final Pattern PAT1 = Pattern.compile("[A-Z][a-z]+");
    public static final Pattern PAT2 = Pattern.compile("(?=\\p{Lu})");

    public static void good() {
        boolean b = PAT1.matcher("Start ").matches();
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call. Problem: Creation XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching in Thread locals may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.newXPath')]
/ancestor::ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.compile')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: org.joda.time.format.DateTimeFormatter or Java 8 java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //FieldDeclaration[@Final=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //FieldDeclaration[@Final=true() and @Static=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')](: has assignment, otherwise check in constructor :)[ancestor::ClassOrInterfaceBodyDeclaration//VariableInitializer],
    //ConstructorDeclaration/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of constructor call :)[not(ancestor::BlockStatement//Expression/PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::ConstructorDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //MethodDeclaration/Block/BlockStatement//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormatter.ofPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'ISODateTimeFormat.')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'DateTimeFormat.fullDateTime')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatterBuilder')][ancestor::PrimaryExpression/PrimarySuffix[@Image="toFormatter"]]
                   ]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Reflection is used in toString or hashCode, which is expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#uuor01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, preferably using Guava.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/AllocationExpression/ClassOrInterfaceType
	[
		typeIs('org.apache.commons.lang.builder.EqualsBuilder')
		or typeIs('org.apache.commons.lang.builder.HashCodeBuilder')
	]
[../../../PrimarySuffix[1]
	[
		@Image='reflectionEquals'
		or @Image='reflectionHashCode'
	]
] |
//PrimaryPrefix/Name
	[
		@Image='EqualsBuilder.reflectionEquals'
		or @Image='HashCodeBuilder.reflectionHashCode'
	]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSimpleDateFormat" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."  typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use a Joda-Time DateTimeFormat to create a specific DateTimeFormatter or Java 8 java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
 //AllocationExpression/ClassOrInterfaceType[typeIs('java.text.SimpleDateFormat')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="StringBuffer is used. It introduces locking overhead, use StringBuilder." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
                    //VariableDeclarator[../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.StringBuffer')]]
                    ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Log String is built irrespective of log level." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') = 'append')
and count(ancestor::IfStatement) = 0
and
count(ancestor::MethodDeclaration/Block/BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList//PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') != 'append')]) = 0
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidWideScopeXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPathExpression targets a wide scope, this is potentially slow." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimarySuffix[
Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/
Literal[starts-with(@Image, '"//')]
and
../PrimaryPrefix/Name[ends-with(@Image, '.compile')]
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXMLGregorianCalendar" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XMLGregorianCalendar is used. It is slow in JAXB." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoxar05">
        <description>Problem: XMLGregorianCalendar is a large object, involving substantial processing. It is created with the poorly performing DatatypeFactory.
            Solution: Add a converter for alternative date handling with joda-time or Java 8 java.time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>

            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.datatype.XMLGregorianCalendar')]
|
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.datatype.XMLGregorianCalendar')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathAPIUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPathAPI is used. XPathAPI implementation has bad performance." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'XPathAPI.')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPath is used. XPath implementation has bad performance." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/
ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[@Image='XPathFactory.newInstance']
[not (ancestor::FieldDeclaration//ClassOrInterfaceType/@Image = 'ThreadLocal')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodeQuality.md#incorrect-equals-and-hashcode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... and @Entity objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'
or @Image='Singleton' or @Image='Component' or @Image='Service' or @Image='Repository' or @Image='Configuration' or @Image='Endpoint' or @Image='RestController' or @Image='ControllerAdvice'
or starts-with(@Image, 'Xml') or @Image='Entity' or @Image='Embeddable' or @Image='MappedSuperclass'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false()]
[not(./ExtendsList/ClassOrInterfaceType[ends-with(@Image, 'Exception') or ends-with(@Image, 'Throwable')])]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[
(not (../Annotation//Name[@Image = 'XmlElement']))
and
(
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
)
and
(not (
ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='equals' or @Name='hashCode'])
)
and
((ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[ends-with(@SimpleName, 'Dto')]
or
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
)]
]
]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
    </rule>

    <rule name="JAXBContextCreatedForEachMethodCall" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="JAXBContext is created for each method call, which is expensive."  typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXBContext creation is expensive because it does much class loading.  &#13;
            Solution: Since JAXBContext objects are thread safe, they can be shared between requests and reused. So, reuse created instances, e.g. as singletons.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'JAXBContext.newInstance']
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="MDCPutWithoutRemove" message="MDC put is used without finally remove." class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//StatementExpression//Name[@Image='MDC.put']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)[not(@Image=
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion']/Block)//Name[@Image='MDC.remove']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)/@Image)
and not((ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion']/Block)//Name[@Image='MDC.clear'])
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public void bad() {
        MDC.put("levelKey1", "levelName1"); // bad, not removed in finally
        MDC.put("levelKey2", "levelName2"); // bad, not removed at all
        doStuff();
        MDC.remove("levelKey1");
    }
}

class Good {
    public void good() {
        try {
            MDC.put("levelKey1", "levelName1");
            MDC.put("levelKey2", "levelName2");
            doStuff();
        } finally {
            MDC.remove("levelKey1");
            MDC.remove("levelKey2");
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MinimizeAttributesInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Attribute is set in the session, yet not removed. This may bloat the session." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tmsu01">
        <description>An attribute is set in the session and not removed. Problem: This may be a large object and data in the sessions takes heap space and stay in the session until time-out. This may take substantial heap space.&#13;
            Solution: remove the attribute if not really needed in the session, remove it from the session as soon as possible. Alternatively, use render parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration/MethodDeclaration[../..//(VariableDeclaratorId |ReturnStatement/Expression)[pmd-java:typeIs('javax.portlet.PortletSession') or pmd-java:typeIs('javax.servlet.http.HttpSession')]]
/Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'removeAttribute')]
)]]
,
//ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement[
.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
)]]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    PortletSession session; // same for HttpSession
    public void setAttribute(String name, Object obj) {
	    session.setAttribute(name, obj);                 // bad
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
}

class Good {
    PortletSession session; // same for HttpSession
	public void setAttribute(String name, final Object obj) {
		session.setAttribute(name, obj);
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
	public void removeAttribute(String name) {
		session.removeAttribute(name);
	}
}
            ]]>
        </example>
    </rule>

    <rule name="ObjectMapperCreatedForEachMethodCall" message="An ObjectMapper is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"   typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOJAR01">
        <description>Problem: Jackson ObjectMapper creation is expensive because it does much class loading.  &#13;
            Solution: Since ObjectMapper objects are thread-safe after configuration in one thread, they can be shared afterwards between requests and reused. So, reuse created instances, from a static field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	(typeIs('com.fasterxml.jackson.databind.ObjectMapper')) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="UnconditionalConcatInLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="String concatenation (+) is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
			//PrimaryPrefix/Name[ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or ends-with(@Image,'.info')]/../../PrimarySuffix/Arguments/ArgumentList/Expression/AdditiveExpression
			[PrimaryExpression/PrimaryPrefix/Name]
			[not(ancestor::IfStatement/Expression/PrimaryExpression/PrimaryPrefix/Name[
			ends-with(@Image,'.isTraceEnabled')
			or ends-with(@Image,'.isDebugEnabled')
			or ends-with(@Image,'.isInfoEnabled')
			or ends-with(@Image,'.isLoggable')
			])]
]]></value>
            </property>
        </properties>
    </rule>

    <rule name="UnconditionalOperationOnLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Operation is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il03">
        <description>Problem: An operation is executed regardless of log level. This could be much processing while the result is typically not used. Detected are obj.toString() and operations with one or more arguments except usually cheap obj.get(arg).&#13;
            Solution: Execute the operation only conditionally and utilize SLF4J formatting with {}-placeholders.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
          //PrimaryPrefix/Name
            (: log levels typically/often not enabled :)
            [
            	ends-with(@Image,'.trace')
            	or ends-with(@Image,'.debug')
            	or ends-with(@Image,'.info')
            ]
            (: no violation if conditionally: only executed if level enabled is okay :)
            [not(ancestor::IfStatement//Name
            	[
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
	        ]
            (: no violation if return conditionally before :)
            [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
                [
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
            ]
	        (: in the log method :)
            /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
            [
                (: toString on argument :)
                PrimaryPrefix/Name[ends-with(@Image,'.toString')]
                or
                (: a method call with an argument list :)
                (PrimarySuffix/Arguments/ArgumentList)
                (: exclude a simple get(i), like list.get(0) or map.get(key), assumed to be fast :)
                and not (PrimaryPrefix/Name[ends-with(@Image,'.get')])
            ]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
            LOG.debug("customer = {}", customer.toString()); // bad
            LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage())); // bad

            LOG.debug("customer = {}", customer); // good
            if (LOG.isDebugEnabled()) { // good
                LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage()));
            }
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutDisableConnectionState" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="A HttpClient builder is used and disableConnectionState is not called. HTTP client tracks connection state while using TLS" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi07">
        <description>Problem: NTLM authenticated connections and SSL/TLS connections with client certificate authentication are stateful: they have a specific user identity/security context per session. If HttpClients have enabled connection state tracking which is the default, established TLS connections will not be reused because it is assumed that the user identity or security context may differ.
            Then performance will suffer due to a full TLS handshake for each request.&#13;
            Solution: HttpClients should disable connection state tracking in order to reuse TLS connections, since service calls for one pool have the same user identity/security context for all sessions. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(:locally created http client builder without disableConnectionState :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
(@Image="HttpClientBuilder.create" or @Image="HttpAsyncClientBuilder.create" or @Image="HttpClients.custom") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
,
(: method param http client builder without disableConnectionState :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
(@Image="HttpClientBuilder" or @Image="HttpAsyncClientBuilder" or @Image="HttpClients") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="HttpClientBuilderWithoutPoolSize" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="HttpClient builder is used and setMaxConnTotal and/or setMaxConnPerRoute is not called. HttpClient defaults of 2 per route and 20 max total are probably not right." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IBI03">
        <description>Problem: default there are only 2 connections per route available. When two external calls are being made, a third thread requesting a connection must wait for free connection.&#13;
            Solution: HttpClients should explicitly define the number of connections per route. If only one route is used make the max number of connections equal to conn per route. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder without setMaxConnTotal :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal')])
]
,
(: locally created http client builder without setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
 and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnPerRoute')])
]
,
(: method param http client builder without setMaxConnTotal :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal')])
]
,
(: method param http client builder without setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
  (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnPerRoute')])
]
,
(: method param PoolingHttpClientConnectionManager without setMaxTotal :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal')])
]
,
(: method param PoolingHttpClientConnectionManager without setDefaultMaxPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultMaxPerRoute')])
]
,
(: new PoolingHttpClientConnectionManager without setMaxTotal :)
//MethodDeclaration//PrimaryExpression//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal')])
]
,
(: method param PoolingHttpClientConnectionManager without setDefaultMaxPerRoute :)
//MethodDeclaration//PrimaryExpression//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultMaxPerRoute')])
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create() // bad, missing setMaxConnPerRoute and setMaxConnTotal
                .setConnectionManager(conMgr)
                .build();

        return HttpClientBuilder.create() // good, both setMaxConnPerRoute and setMaxConnTotal called
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarningsHighRisk" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Using SuppressWarnings for a rule that is meant to prevent high risk problems." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative) Problem: This rule detects high risk problems, suppressing them without full knowledge can lead to incidents like customer data mix-up, corrupt data, server crashes or very bad performance. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so these can be fixed. (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="ruleIdMatches" type="String" value="AvoidUnguardedMutableFieldsInSharedObjects|AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects|AvoidMutableStaticFields|[^\w]ALL[^\w]|[^\w]all[^\w]|PMD[^\.]|pmd[^:]"
                      description="Regex for inclusion of high risk rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of high risk rules"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="UsingSuppressWarnings" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Using SuppressWarnings." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative) Problem: This rule detects problems, suppressing them without full knowledge can lead to the problems this rule is trying to prevent. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so these can be fixed. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="ruleIdMatches" type="String" value=".*"
                      description="Regex for inclusion of rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of rules"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidTimeUnitConfusion" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="A variable identifier or @Value member ends with timeToLive, expiryTime or timeout, time unit is missing." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaratorId[ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'expirytime')
or ends-with(lower-case(@Name), 'timeout')]
,
//SingleMemberAnnotation/Name[@Image='Value']/..//Literal[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad

@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeSeconds}") long timeToLiveSeconds) { // 2x good

            ]]>
        </example>
    </rule>

    <rule name="InconsistentEqualsAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Equals and hashCode are not based on the same fields or use inconsistent conversion." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: If equals and hashCode are inconsistent, strange things can happen like adding the object to a Set and not being able to find it back.&#13;
            Solution: Use the same fields in equals and hashCode and if conversions are needed, use identical conversions in both. So don't use equalsIgnoreCase. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[(@Name = ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='equals']/Block//(Name|PrimarySuffix)/@Image) !=
(@Name = ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='hashCode']/Block//(Name|PrimarySuffix)/@Image)
]
,
//MethodDeclaration[@Name='equals']/Block//Name[ends-with(@Image, 'equalsIgnoreCase')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad1 {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryoutBad3 that = (EqHashTryoutBad3) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1); // field2 missing
    }
}

class Bad2 {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryoutBad2 that = (EqHashTryoutBad2) o;
        if (field1 != null ? !field1.equals(that.field1) : that.field1 != null) return false;
        return field2 != null ? field2.equalsIgnoreCase(that.field2) : that.field2 == null; // ignore case
    }
    public int hashCode() {
        int result = field1 != null ? field1.hashCode() : 0;
        result = 31 * result + (field2 != null ? field2.hashCode() : 0);
        return result;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInEquals" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Field simply assigned to is missing in equals method." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah04">
        <description>Problem: If a field which can be assigned separately (independent of other fields) is missing in the equals method, then changing the field in one object has no effect on the equality with another object.
            However, if a field of one of two equal objects is changed, the expectation is that they are no longer equal.&#13;
            Solution: include the missing field in the equals and hashCode method. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]//VariableDeclaratorId[
(: names used as left hand side in simple assignments in methods or constructor matching fields:)
 (@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/(MethodDeclaration|ConstructorDeclaration)
/..//BlockStatement//StatementExpression
(: simple assignment :)
[exists(AssignmentOperator) and not(exists(Expression/PrimaryExpression/PrimarySuffix))
and exists(Expression/PrimaryExpression/PrimaryPrefix/Name) and not(contains(Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,".")) ]
/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)/@Image)
 and (
(: with an equals method defined at that level with 1 argument and not having a throw statement :)
ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and not (Block/BlockStatement/Statement/ThrowStatement)]
(: where names used in equals method matching fields are non-equal to :)
and not(@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1]/Block//
(: name or this.name and name before dot if present :)
(Name|PrimarySuffix)/(substring-before(concat(@Image, '.'), '.'))) )]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; // bad, missing in equals

    public Bad1(String arg2) {
        field2 = arg2;
    }
    public void setField1(String arg1) {
        field1 = arg1;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidCalendar"
          language="java"
          message="A Calendar is inefficient in memory usage."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#imu01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use Date, Java 8+ java.time.[Local/Zoned]DateTime or joda time [Local]DateTime.
        </description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//(Type)[pmd-java:typeIs('java.util.Calendar')]
,
//Name[starts-with(@Image, 'Calendar.')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CalendarStuff {
    Calendar field1; // bad

    private Calendar bad1() {
        return Calendar.getInstance();
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableLists"
          language="java"
          message="List is not modified, make it immutable or unmodifiable"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml01">
        <description>Problem: A list which is unnecessarily mutable may accidentally be added to and cause a memory leak. &#13;
            Solution: Make it impossible to modify the list after initialization: use Java 9 List.of, Collections.unmodifiableList or Guava ImmutableList.
        </description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    (: a field of type List :)
    //FieldDeclaration[pmd-java:typeIs('java.util.List')]//VariableDeclaratorId[
    (: with a method defined at that level that does not use the field with a modify operation (case field.modOp) :)
    not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
    starts-with(substring-after(@Image, '.'), 'add') or
    starts-with(substring-after(@Image, '.'), 'remove') or
    substring-after(@Image, '.') = 'set' or
    substring-after(@Image, '.') = 'clear' or
    substring-after(@Image, '.') = 'replaceAll' or
    substring-after(@Image, '.') = 'retainAll'
    ]/(substring-before(concat(@Image, '.'), '.')))]
    [ (: and case this.field.modOp() :)
not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression
/PrimarySuffix[starts-with(@Image, 'add') or starts-with(@Image, 'remove') or @Image = 'set' or @Image = 'clear' or @Image = 'replaceAll' or @Image = 'retainAll']
/preceding-sibling::PrimarySuffix/@Image)
    ]     (: and :)
    [( (: field is initialized with List allocation :)
    ../VariableInitializer/Expression//AllocationExpression[pmd-java:typeIs('java.util.List')]
    or
    (: or static block / constructor has field initialized with List allocation :)
    ancestor::ClassOrInterfaceBody//(Initializer|ConstructorDeclaration)//AssignmentOperator[exists(../Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.List')])]/..//Name/@Image = @Name
    or
    (: or constructor has a simple assignment to the field, param of literal: no arguments :)
    ancestor::ClassOrInterfaceBody//ConstructorDeclaration//AssignmentOperator[exists(../Expression[pmd-java:typeIs('java.util.List')]) and not(exists(../Expression/PrimaryExpression/PrimarySuffix))]/..//Name/@Image = @Name
    )]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Bad {
    List unmutated = new ArrayList(Arrays.asList("one", "two")); // bad
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
public class Good {
    List unmutated1 = Collections.unmodifiableList(Arrays.asList("one", "two")); // Java 8
    List unmutated2 = List.of("one, "two"); // Java 9+
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidJAXBUtil"
          language="java"
          message="The JAXB utility class is not optimized for performance."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXB utility methods do not reuse JAXBContext when more that one context is used. &#13;
            Solution: use JAXB API directly for marshalling and unmarshalling to gain all the performance benefits as described in IUOXAR04 and IUOXAR06.
        </description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression[pmd-java:typeIs('javax.xml.bind.JAXB')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class XMLConversion {
    public <T> T myUnmarshal(final Source response, final Class<T> clazz) {
        return JAXB.unmarshal(response, clazz); // bad
    }
    public void myMarshal(final Object response, StringWriter stringWriter) {
        JAXB.marshal(response, stringWriter); // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnnecessaryStringBuilderCreation"
          language="java"
          message="Use concatenation (+) instead of new StringBuilder if only one statement."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu05">
        <description>Problem: Creating a StringBuilder and using append is more verbose, less readable and less maintainable than simply using String concatenation (+).
            For one statement resulting in a String, creating a StringBuilder and using append is not faster than simply using concatenation.&#13;
            Solution: Simply concatenate Strings in one statement, it is more concise, better readable and more maintainable.
        </description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: append used in one chained statement on allocated StringBuilder and with chained toString :)
//MethodDeclaration//Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/../../../PrimarySuffix[@Image = "toString"]/../PrimarySuffix[@Image = "append"][1] (: only report first append in chain :)
|
(: or :)
(: append on builder var, where var is allocated as builder :)
//MethodDeclaration//Block//PrimaryPrefix/Name[ends-with(@Image, '.append') and starts-with(@Image,
ancestor::Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/ancestor::VariableDeclarator/VariableDeclaratorId/@Name)
and
(
(: and either 1. toString is called in a chain after append :)
../../PrimarySuffix[@Image = 'toString'] or
(: or 2. toString is called on the var in same block :)
substring-before(@Image, '.') = substring-before(ancestor::Block//PrimaryPrefix/Name[ends-with(@Image, '.toString')]/@Image, '.'))
(: and not append on var used in inner block like a ForStatement :)
and not(ancestor::Block//Block//PrimaryPrefix/Name[ends-with(@Image, '.append')])
(: and var not passed as argument to method :)
and not(substring-before(@Image, '.') = ancestor::Block//Statement//PrimarySuffix/Arguments//Name/@Image)
]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    String name;
    String value;

    public String bad() {
        return new StringBuilder()
           .append(name) // bad
           .append(" = ")// bad
           .append(value)// bad
           .toString();
    }

    public String good() {
        return name + " = " + value;
    }
}
            ]]>
        </example>
    </rule>

</ruleset>